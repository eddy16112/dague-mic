extern "C" %{
/*
 *  Copyright (c) 2010      
 * 
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include <plasma.h>
#include <core_blas.h>
#include <string.h>

#include "dague.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"

#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"
#include "dplasma/lib/butterfly_map.h"

#define NOT_TRANSPOSE 0x0
#define TRANSPOSE     0x1

void BFT_zQTL( int mb, int nb, int lda, int off, int lvl, int N,
          PLASMA_Complex64_t *tl, PLASMA_Complex64_t *bl,
          PLASMA_Complex64_t *tr, PLASMA_Complex64_t *br,
          PLASMA_Complex64_t *C, int is_transpose, int is_diagonal );
void BFT_zQBL( int mb, int nb, int lda, int off, int lvl, int N,
          PLASMA_Complex64_t *tl, PLASMA_Complex64_t *bl,
          PLASMA_Complex64_t *tr, PLASMA_Complex64_t *br,
          PLASMA_Complex64_t *C, int is_transpose, int is_diagonal );
void BFT_zQTR_trans( int mb, int nb, int lda, int off, int lvl, int N,
          PLASMA_Complex64_t *tl, PLASMA_Complex64_t *bl,
          PLASMA_Complex64_t *tr, PLASMA_Complex64_t *br,
          PLASMA_Complex64_t *C, int is_transpose, int is_diagonal );
void BFT_zQTR( int mb, int nb, int lda, int off, int lvl, int N,
          PLASMA_Complex64_t *tl, PLASMA_Complex64_t *bl,
          PLASMA_Complex64_t *tr, PLASMA_Complex64_t *br,
          PLASMA_Complex64_t *C, int is_transpose, int is_diagonal );
void BFT_zQBR( int mb, int nb, int lda, int off, int lvl, int N,
          PLASMA_Complex64_t *tl, PLASMA_Complex64_t *bl,
          PLASMA_Complex64_t *tr, PLASMA_Complex64_t *br,
          PLASMA_Complex64_t *C, int is_transpose, int is_diagonal );

%}

[DAGUE_ARENA_STRUT = 36]
descA  [type = "dague_seg_ddesc_t"]
A      [type = "dague_ddesc_t *"]
nt     [type = "int"]
mt     [type = "int"]
pool_0 [type = "dague_memory_pool_t *" size = "(sizeof(PLASMA_Complex64_t)*descA.A_org.mb*descA.A_org.nb)"]


/*
 *
 */
GEBRT(i,j)
  /* Execution space */
  i = 0 .. mt/2-1
  j = 0 .. nt/2-1

  : A(i,j)

  /* Atl: A from Top Left */ 
  RW  Atl <- A GEBRT_Reader(i,j) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
          -> A GEBRT_Writer(i,j) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]

  /* Abl: A from Bottom Left */
  RW  Abl <- A GEBRT_Reader(i+mt/2,j) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
          -> A GEBRT_Writer(i+mt/2,j) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]

  /* Atr: A from Top Right */
  RW  Atr <- A GEBRT_Reader(i,j+nt/2) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
          -> A GEBRT_Writer(i,j+nt/2) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]

  /* Abr: A from Bottom Right */
  RW  Abr <- A GEBRT_Reader(i+mt/2,j+nt/2) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
          -> A GEBRT_Writer(i+mt/2,j+nt/2) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]

BODY

  unsigned mb_seg, nb_seg, lda, N;
  uintptr_t off_in_U, off_in_tile;
  int type, sz, type_exists, i_tile, j_tile;
  void *p_elem_tl, *p_elem_bl, *p_elem_tr, *p_elem_br;

  type = segment_to_type_index(descA.seg_info, i, j);
  type_exists = type_index_to_sizes(descA.seg_info, type, &mb_seg, &nb_seg);
  assert( type_exists );
  lda = descA.A_org->mb; /* This is the mb of the tile */
  segment_to_tile(&descA, i, j, &i_tile, &j_tile, &off_in_tile);

  /* off_in_U is the beginning (vertically) of the segment as an absolute offest
   * from the top of the original matrix */
  off_in_U = i_tile*lda + off_in_tile%lda;
  N = descA.A_org->lm;

  p_elem_tl = dague_private_memory_pop( pool_0 );
  p_elem_bl = dague_private_memory_pop( pool_0 );
  p_elem_tr = dague_private_memory_pop( pool_0 );
  p_elem_br = dague_private_memory_pop( pool_0 );

  BFT_zQTL( mb_seg, nb_seg, lda, off_in_U, descA.level, N, Atl, Abl, Abl, Abr, p_elem_tl, NOT_TRANSPOSE, 0);
  BFT_zQBL( mb_seg, nb_seg, lda, off_in_U, descA.level, N, Atl, Abl, Abl, Abr, p_elem_bl, NOT_TRANSPOSE, 0);
  BFT_zQTR( mb_seg, nb_seg, lda, off_in_U, descA.level, N, Atl, Abl, Abl, Abr, p_elem_tr, NOT_TRANSPOSE, 0);
  BFT_zQBR( mb_seg, nb_seg, lda, off_in_U, descA.level, N, Atl, Abl, Abl, Abr, p_elem_br, NOT_TRANSPOSE, 0);

  sz = (lda*(nb_seg-1)+mb_seg) * sizeof(PLASMA_Complex64_t);
  memcpy(Atl, p_elem_tl, sz);
  memcpy(Abl, p_elem_bl, sz);
  memcpy(Atr, p_elem_tr, sz);
  memcpy(Abr, p_elem_br, sz);

  dague_private_memory_push( pool_0, p_elem_tl );
  dague_private_memory_push( pool_0, p_elem_bl );
  dague_private_memory_push( pool_0, p_elem_tr );
  dague_private_memory_push( pool_0, p_elem_br );

  /* printf("GEBRT(%d,%d)\n",i,j); */
END


/*
 *
 */
GEBRT_Reader(i,j)
  /* Execution space */
  i = 0 .. mt-1
  j = 0 .. nt-1

  : A(i,j)

READ A <- A(i, j)                                     [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]         
       -> ( (i<mt/2)  && (j<nt/2)  ) ? Atl GEBRT(i,j) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
       -> ( (i<mt/2)  && (j>=nt/2) ) ? Atr GEBRT(i,j-nt/2) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
       -> ( (i>=mt/2) && (j<nt/2)  ) ? Abl GEBRT(i-mt/2,j) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
       -> ( (i>=mt/2) && (j>=nt/2) ) ? Abr GEBRT(i-mt/2,j-nt/2) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]

BODY
/* nothing */
  /* fprintf(stderr,"GEBRT_Reader(%d,%d)\n",i,j); */
END


/*
 *
 */
GEBRT_Writer(i,j)
  /* Execution space */
  i = 0 .. mt-1
  j = 0 .. nt-1

  : A(i,j)

READ A <- ( (i<mt/2)  && (j<nt/2)  ) ? Atl GEBRT(i,j) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
       <- ( (i<mt/2)  && (j>=nt/2) ) ? Atr GEBRT(i,j-nt/2) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
       <- ( (i>=mt/2) && (j<nt/2)  ) ? Abl GEBRT(i-mt/2,j) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
       <- ( (i>=mt/2) && (j>=nt/2) ) ? Abr GEBRT(i-mt/2,j-nt/2) [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]
       -> A(i, j)                                               [ arena_index = inline_c %{ return segment_to_arena_index(descA, i, j); %}]         

BODY
/* nothing */
  /* fprintf(stderr,"GEBRT_Writer(%d,%d)\n",i,j); */
END


