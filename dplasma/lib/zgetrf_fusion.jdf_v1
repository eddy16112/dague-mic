extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include <plasma.h>
#include <core_blas.h>
#include <math.h>

#include "dague.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"
#include "dplasma/cores/dplasma_zcores.h"


#define IEVN 0
#define IODD (descA.nb)
#define MAXI (descA.nb*2)
#define SRCH (descA.nb*3)
#define PIVO (descA.nb*4)

%}

/* Globals
 */
A            [type = "dague_ddesc_t *"]
IPIV         [type = "dague_ddesc_t *"]
LMAX         [type = "dague_ddesc_t *"]
V            [type = "dague_ddesc_t *"]
BUFFER       [type = "dague_ddesc_t *"]
ACOPY        [type = "dague_ddesc_t *"]
P            [type = "int"]
Q            [type = "int"]
INFO         [type = "int*"]

descA        [type = "tiled_matrix_desc_t" hidden=on default="*((tiled_matrix_desc_t*)A)" ]


/**************************************************
 *                    IP_in (pseudo task)
 **************************************************/
IP_in(k,m)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = 0..inline_c %{ return dague_imin( descA.mt-k-1, P-1 ); %}

// Parallel partitioning
:IPIV((k+m)%P,k/* %Q */)

// Parameters
READ  IP <- IPIV((k+m)%P,k/* %Q */)                                                               [type = PIVOT]
         -> IP GETRF_FNL(k,(k+m)..(descA.mt-((descA.mt-k-m-1)%P)-1)..P)                         [type = PIVOT]

;descA.mt-k-1

BODY
        /* Nothing to do */
END

/**************************************************
 *                    IP_out (pseudo task)
 **************************************************/
IP_out(k,m)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = 0..inline_c %{ return dague_imin( descA.mt-k-1, P-1 ); %}

// Parallel partitioning
:IPIV((k+m)%P,k/*%Q*/)

// Parameters
READ  IP <- IP GETRF_FNL(k,k+m)                                                             [type = PIVOT]
   -> IPIV((k+m)%P,k/*%Q*/)                                                               [type = PIVOT]

;descA.mt-k-1

BODY
        /* Nothing to do */
END


/**************************************************
 *                    V_in (pseudo task)
 **************************************************/
V_in(k,m)

// Execution space
k = 0 .. ((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k .. (descA.mt-1)

// Parallel partitioning
:V((k+m)%P,k%Q)

// Parameters
READ  V <- V((k+m)%P,k%Q)                                       [type = SWAP]
        -> V GETRF_MAX(k,m,0)                                 [type = SWAP]

;descA.mt-k-1

BODY
    /* Nothing to do */
END

/**************************************************
 *                    LMAX_in (pseudo task)
 **************************************************/
LMAX_in(k,m)

// Execution space
k = 0 .. ((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k .. descA.mt-1

// Parallel partitioning
:LMAX(m,k%Q)

// Parameters
READ  M <- LMAX(m,k%Q)                                          [type = MAXL]
       -> M GETRF_MAX(k,m,0)                                    [type = MAXL]

BODY
    /* Nothing to do */
END



/**************************************************
 *                    GETRF_MAX
 * Apply the scale and the update of the step h-1
 * Look for the local tile max of the step h
 **************************************************/
GETRF_MAX(k,m,h)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k..descA.mt-1
h = 0..inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1;%}

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0;nb_init != 1 ;i++)
      nb_init/=2;
  return i;%}

mmax = inline_c %{return ((descA.mt-k < P) ? descA.mt-k : P);%}

hmax = inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1;%}

// Parallel partitioning
:A(m, k)

RW  T <- ((k == 0) && (h == 0))? A(m, k)
      <- ((k != 0) && (h == 0))? C GEMM(k-1, m, k)
      <- ((h != 0))? T GETRF_MAX(k,m,h-1)
      -> (h != hmax)? T GETRF_MAX(k,m,h+1)
      -> (h == hmax)? T GETRF_FNL(k,m)

RW  V <- (h == 0)? V V_in(k,m)                                                                   [type = SWAP]
      <- (h != 0)? W GETRF_SND(k,dmax,m-k,h-1)                                                   [type = SWAP]
      -> (m-k < P)? V GETRF_SVM(k,m-k,h)                                                         [type = SWAP]

RW  M <- (h == 0)? M LMAX_in(k,m)                                                                [type = MAXL]
      <- (h != 0)? M GETRF_MAX(k,m,h-1)	                                                         [type = MAXL]
      -> (h != hmax)? M GETRF_MAX(k,m,h+1)                                                       [type = MAXL]
      -> Mm GETRF_RDC(k,(m-k)%P,(m-k)/P,h)							 [type = MAXL]
      -> ((k+((m-k)%P)+(((m-k)/P)*2+1)*P) >= descA.mt)? Mg GETRF_RDC(k,(m-k)%P,(m-k)/P,h)        [type = MAXL]
      -> ((k+((m-k)%P)+(((m-k)/P)*2+2)*P) >= descA.mt)? Md GETRF_RDC(k,(m-k)%P,(m-k)/P,h)        [type = MAXL]

;descA.mt-k-1

BODY
    DRYRUN(
       int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
       int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
       int ldam = BLKLDD( descA, m );
       int i;
       int p = (m == k)? h : 0;
       int index;
       double max;
       int irecv = (h%2 == 0)? IEVN : IODD;
       int isend = (h%2 == 1)? IEVN : IODD;

       dague_complex64_t *lM = (dague_complex64_t*)M;
       dague_complex64_t *lV = (dague_complex64_t*)V;
       dague_complex64_t *lT = (dague_complex64_t*)T;


       if(h != 0)		
       {
	 /* Applying the previous swap */	 
	 if(m == k) {
	     cblas_zcopy(tempkn, lV + MAXI, 1,
			         lT + h-1,  ldam);
	 }

	 int owner_last_index = ((int) (lV[PIVO + h-1]))/descA.mb;
	 int last_index       = ((int) (lV[PIVO + h-1]))%descA.mb;

	 if(owner_last_index == m) {
	   cblas_zcopy(tempkn, lV + irecv,       1,
		               lT + last_index, ldam);
	 }

	 /* Appliying the update */
	 dague_complex64_t alpha = ((dague_complex64_t)1.) / (lV[MAXI + h-1]);
	 cblas_zscal(tempmm-p, CBLAS_SADDR( alpha ), lT + ((h-1)*ldam+p), 1 );
	 dague_complex64_t mzone = -1.;
	 cblas_zgeru(CblasColMajor, tempmm-p, tempkn-h,
		     CBLAS_SADDR(mzone),
		     lT+ ldam * (h-1) + p,    1,
		     lV+ MAXI         + h, 1,
		     lT+ ldam *  h    + p,    ldam);
       }

       /* Saving the default swap line */
       if(m == k)
	 cblas_zcopy(tempkn, lT + h,    ldam,
		             lV + isend, 1);

       /* Looking for the local max */
       index = p;
       max = cabs(lT[ldam*h+p]);
       for(i = p+1;i < tempmm;i++) { 
	 if(cabs(lT[ldam*h+i]) > max)
	   {
	     index = i;
	     max = cabs( lT[ldam*h+i] );
	   }
       }

       cblas_zcopy(tempkn, lT + index, ldam,
                           lM + 1,     1);
       lM[0] = (dague_complex64_t)(index+m*descA.mb);
          );
    printlog();
END

/**************************************************
 *                    GETRF_RDC
 * Look for the local node max of the step h 
 *
 **************************************************/
GETRF_RDC(k,r,m,h)

k = 0 .. ((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
r = 0 .. ((descA.mt-k < P) ? descA.mt-k-1 : P-1)
m = 0 .. inline_c %{
  int ret = -1;
  int i;
  for(i = k; i < descA.mt ;i++)
    if((i-k)%P == r)
      ret++;
  return ret;%}
h = 0..inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1;%}

rmax = inline_c %{ return ((descA.mt-k < P) ? descA.mt-k-1 : P-1); %}

mmax = inline_c %{
  int ret = -1;
  int i;
  for(i = k; i < descA.mt ;i++)
    if((i-k)%P == r)
      ret++;
  return ret;%}

hmax = inline_c %{
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1;%}

// Parallel partitioning
:A(k+r, k)

RW    Mm <- M GETRF_MAX(k,k+r+P*m,h)                                                                           [type = MAXL]
         -> ((m != 0) && ((m%2) == 0))? Md GETRF_RDC(k,r,(m-1)/2,h)                                            [type = MAXL]
         -> ((m != 0) && ((m%2) == 1))? Mg GETRF_RDC(k,r,(m-1)/2,h)                                            [type = MAXL]
         -> (m == 0)? M GETRF_SVM(k,r,h)                                                                       [type = MAXL]
READ  Mg <- ((m*2+1) <= mmax)? Mm GETRF_RDC(k,r,m*2+1,h) : M GETRF_MAX(k,k+r+P*m,h)                            [type = MAXL]
READ  Md <- ((m*2+2) <= mmax)? Mm GETRF_RDC(k,r,m*2+2,h) : M GETRF_MAX(k,k+r+P*m,h)                            [type = MAXL]

;descA.mt-k-1

BODY
    DRYRUN(
       int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);

       dague_complex64_t *lMm = (dague_complex64_t*)Mm;
       dague_complex64_t *lMg = (dague_complex64_t*)Mg;
       dague_complex64_t *lMd = (dague_complex64_t*)Md;

       if(cabs(lMm[1+h]) < cabs(lMg[1+h]))
	 cblas_zcopy(tempkn+1, lMg, 1,
		               lMm, 1);

       if(cabs(lMm[1+h]) < cabs(lMd[1+h]))
	 cblas_zcopy(tempkn+1, lMd, 1,
			       lMm, 1);
          );
    printlog();
END

/**************************************************
 *                    GETRF_SVM
 * Saving the local node max in the V workspace
 *
 **************************************************/
GETRF_SVM(k,m,h)

k = 0 .. ((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = 0 .. ((descA.mt-k < P) ? descA.mt-k-1 : P-1)
h = 0..inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1;%}

mmax = inline_c %{return ((descA.mt-k < P) ? descA.mt-k : P);%}

// Parallel partitioning
:A(k+m, k)

RW    V  <- V GETRF_MAX(k,k+m,h)                                                                           [type = SWAP]
         -> V GETRF_SND(k,0,m,h)                                                                           [type = SWAP]
         -> W GETRF_SND(k,0,(m+1)%mmax,h)                                                                  [type = SWAP]

READ  M <-  Mm GETRF_RDC(k,m,0,h)                                                                          [type = MAXL]

;descA.mt-k-1

BODY
    DRYRUN(
       int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);

       dague_complex64_t *lV = (dague_complex64_t*)V;
       dague_complex64_t *lM = (dague_complex64_t*)M;

       lV[PIVO + h] = (int) lM[0];
       cblas_zcopy(tempkn, lM + 1,    1,
		           lV + SRCH, 1);
          );
    printlog();
END

/**************************************************
 *                    GETRF_SND
 * Look and share the global max of the step h 
 * by using the Bruck algorithm
 **************************************************/
GETRF_SND(k,d,m,h)

k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
d = 0.. inline_c %{ 
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0;nb_init != 1 ;i++)
      nb_init/=2;
  return i;%}
m = 0..((descA.mt-k < P) ? (descA.mt-k-1) : (P-1))
h = 0..inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1;%}

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0;nb_init != 1 ;i++)
      nb_init/=2;
  return i;%}

mmax = inline_c %{return ((descA.mt-k < P) ? descA.mt-k : P);%}

hmax = inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1;%}

pui= inline_c %{ return (int) pow(2,d+1);%}

// Parallel partitioning
:A(k+m, k)

READ  V <- (d == 0)? V GETRF_SVM(k,m,h) : W GETRF_SND(k,d-1,m,h)                                           [type = SWAP]
RW    W <- (d == 0)? V GETRF_SVM(k,(mmax+m-1)%mmax,h) : W GETRF_SND(k,d-1,(mmax+m-pui/2)%mmax,h)           [type = SWAP]
	-> (d != dmax)? V GETRF_SND(k,d+1,m,h)	                                                           [type = SWAP]
        -> (d != dmax)? W GETRF_SND(k,d+1,(m+pui)%mmax,h)	                                           [type = SWAP]
        -> ((h != hmax) && (d == dmax))? V GETRF_MAX(k,(k+m)..(descA.mt-((descA.mt-(k+m+1))%P)-1)..P, h+1) [type = SWAP]
        -> ((h == hmax) && (d == dmax))? V GETRF_FNL(k,(k+m)..(descA.mt-((descA.mt-(k+m+1))%P)-1)..P)      [type = SWAP]

;descA.mt-k-1

BODY
    DRYRUN(
       int isend = (h%2 == 1)? IEVN : IODD;
       int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);

       dague_complex64_t *lV = (dague_complex64_t*)V;
       dague_complex64_t *lW = (dague_complex64_t*)W;


       if(m  < pui && m < pui/2)
	 cblas_zcopy(tempkn, lV + isend, 1,
		             lW + isend, 1);

       if(cabs(lV[SRCH + h]) > cabs(lW[SRCH + h]))
	 {
	   lW[PIVO + h] = lV[PIVO + h];
	   cblas_zcopy(tempkn, lV + SRCH, 1,
		               lW + SRCH, 1);
	 }

       if(d == dmax)
	 cblas_zcopy(tempkn, lW + SRCH, 1,
		             lW + MAXI, 1);

          );
    printlog();
END

/**************************************************
 *                    GETRF_FNL
 * Apply the last scale and update. Then send the
 * pivot to the swap operations.
 **************************************************/
GETRF_FNL(k,m)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k..descA.mt-1

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0;nb_init != 1 ;i++)
      nb_init/=2;
  return i;%}

hmax = inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1;%}


// Parallel partitioning
:A(m, k)

RW    T <- T GETRF_MAX(k,m,hmax)
        -> (m == k) ? T TRSM_U(k, k+1..descA.mt-1) : A GEMM(k,m, k+1..descA.nt-1)
        -> A(m, k)
READ  V <- W GETRF_SND(k,dmax,(m-k)%P,hmax)                  [type = SWAP]
RW   IP <- IP IP_in(k,(m-k)%P)                               [type = PIVOT]
        -> (m-k < P)? IP IP_out(k,(m-k))                     [type = PIVOT]
        -> IP SWAP_COLLECT(k, m, k+1..descA.nt-1)            [type = PIVOT]

;descA.mt-k-1

BODY
 DRYRUN(
   int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
   int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
   int ldam = BLKLDD( descA, m );
   int p = (m == k)? hmax+1 : 0;
   int i;
   int irecv = ((hmax+1)%2 == 0)? IEVN : IODD;

   dague_complex64_t *lV = (dague_complex64_t*)V;
   dague_complex64_t *lT = (dague_complex64_t*)T;


   /* Applying the previous swap */
   if(m == k)
     cblas_zcopy(tempkn, lV + MAXI, 1,
		         lT + hmax, ldam);
	 
   int owner_last_index = ((int) (((dague_complex64_t *) V)[PIVO + hmax]))/descA.mb;
   int last_index = ((int) (((dague_complex64_t *) V)[PIVO + hmax]))%descA.mb;
   if(owner_last_index == m) {
     cblas_zcopy(tempkn, lV + irecv     , 1,
		         lT + last_index, ldam);
   }

   /* Appliying the update */
   dague_complex64_t alpha = ((dague_complex64_t) 1.) / (lV[MAXI + hmax]);
   cblas_zscal(tempmm-p, CBLAS_SADDR( alpha ), lT + hmax*ldam + p, 1 );


   for(i = 0;i <= hmax;i++)
     ((int *) IP)[i] = ((int) lV[PIVO + i]) + 1;
	);
    printlog();
END

/**************************************************
 *                    ACOPY_in (pseudo task)
 **************************************************/
ACOPY_in(k,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
n = k+1..descA.nt-1

// Parallel partitioning
:ACOPY(k%P,n)

// Parameters
READ  A  <- ACOPY(k%P,n)
         -> ACOPY SWAP_COPY(k,n)

;descA.mt-n-1

BODY
        /* Nothing to do */
END

/**************************************************
 *                    SWAP_COPY
 * Copying the A(k,n) and send it to itself
 **************************************************/
SWAP_COPY(k,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
n = k+1..descA.nt-1

// Parallel partitioning
:A(k,n)

// Parameters
READ      A <-  (k == 0)? A(k,n) : C GEMM(k-1, k, n)
RW    ACOPY <-  A ACOPY_in(k,n)
            ->  U SWAP_RECV(k,k,n)
CTL     ctl ->  ctl SWAP_PASTE(k,n)

BODY
    DRYRUN(
            /*int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
            int ldak = BLKLDD( descA, k );
            int i;
            int j;
            for(j = 0;j < tempnn;j++)
                  for(i = 0;i < descA.mt;i++)
                        ACOPY[j*ldak+i] = A[j*ldak+i];*/
          );
    printlog("SWAP_COPY(k=%d,n=%d)\n",d,n);
END


/**************************************************
 *                    SWAP_RECV
 * Swapping all the lines from the A(k,n) copy by
 * the current process then sending it to next process
 **************************************************/
SWAP_RECV(k,m,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k..descA.mt-1
n = k+1..descA.nt-1

// Parallel partitioning
:A(m, n)

// Parameters
/*READ      U <- (m==k)? ACOPY SWAP_COPY(k, n) : ((m-k<P)? U SWAP_RECV(k,m-1,n) : U SWAP_RECV(k,m-P,n))*/
READ      U <- (m==k)? ACOPY SWAP_COPY(k, n)
            <- (m-k<P)? U SWAP_RECV(k,m-1,n) : U SWAP_RECV(k,m-P,n)
            ->  (descA.mt-m>P)? U SWAP_RECV(k,m+P,n)
            ->  (m-k<P-1)? U SWAP_RECV(k,m+1,n)
RW        T <-  T SWAP_COLLECT(k,m,n)
            ->  (m!=k)? C GEMM(k,m,n)
READ     IP <-  IP SWAP_COLLECT(k,m,n)                  [type = PIVOT]

;descA.mt-n-1

BODY
    DRYRUN(
/* <-  (m==k)? A SWAP_COPY(k, n) : ((m-k>=P)? A SWAP_RECV(k,m-P,n) : A SWAP_RECV(k,descA.mt-((descA.mt-m)%P)-1,n))
   ->  ((descA.mt-m<P) && (k+((m-k)%P) != P-1))? A SWAP_RECV(k,k+((m-k)%P),n)*/
          );
    printlog("SWAP_RECV(k=%d,m=%d,n=%d)\n",k,m,n);
END


/**************************************************
 *                    BUFFER_in (pseudo task)
 **************************************************/
BUFFER_in(k,m,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = 0..((P<descA.mt-k)?P-1:descA.mt-k-1)
n = k+1..descA.nt-1

// Parallel partitioning
:BUFFER((k+m)%P,n)

// Parameters
READ  B  <- BUFFER((k+m)%P,n)
         -> MYBUF SWAP_COLLECT(k,k+m,n)

;descA.mt-n-1

BODY
        /* Nothing to do */
END

/**************************************************
 *                    SWAP_COLLECT
 * Swapping all the lines for the current process
 * in the temporary buffer
 **************************************************/
SWAP_COLLECT(k,m,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k..descA.mt-1
n = k+1..descA.nt-1

// Parallel partitioning
:A(m, n)

// Parameters
RW   MYBUF  <-  (m-k>=P)? MYBUF SWAP_COLLECT(k,m-P,n) : B BUFFER_in(k,m-k,n)
            ->  (descA.mt-m>P)? MYBUF SWAP_COLLECT(k,m+P,n)
            ->  ( ((descA.mt-m) <= P) && (((m-k)%P)%2 == 0) )? MYBUF  SWAP_SND(k,0,((m-k)%P)/2,n)
            ->  ( ((descA.mt-m) <= P) && (((m-k)%P)%2 == 1) )? BUFFER  SWAP_SND(k,0,((m-k)%P)/2,n)
            ->  ( ((descA.mt-m) <= P) && (descA.mt-k <  P) && (((descA.mt-k)%2)==1) && (m == descA.mt-1) )? BUFFER SWAP_SND(k,0,((m-k)%P)/2,n)
	    ->  ( ((descA.mt-m) <= P) && (descA.mt-k >= P) && (((P)%2)==1) && (((m+1)%P) == (k%P)) )? BUFFER SWAP_SND(k,0,((m-k)%P)/2,n)
READ      T <-  (k == 0)? A(m,n) : C GEMM(k-1, m, n)
            ->  T SWAP_RECV(k,m,n)
READ     IP <-  IP GETRF_FNL(k,m)                                                                              [type = PIVOT]
            ->  IP SWAP_RECV(k,m,n)                                                                            [type = PIVOT]
            ->  ( ((descA.mt-m) <= P ) && (((m-k)%P)%2 == 0) )? IP    SWAP_SND(k,0,((m-k)%P)/2,n)  	       [type = PIVOT]

;descA.mt-n-1

BODY
    DRYRUN(
          );
    printlog("SWAP_COLLECT(k=%d,m=%d,n=%d)\n",k,m,n);
END


/**************************************************
 *                    SWAP_SND
 * Sending the temporary buffer to the logarithmic
 * neighbor
 **************************************************/
SWAP_SND(k,d,m,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
d = 0.. inline_c %{ 
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0;nb_init != 1 ;i++)
      nb_init/=2;
  return i;%}
m = 0 .. inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0;i <= d ;i++)
      nb_init = (nb_init+1)/2;
  return nb_init-1;%}
n = k+1..descA.nt-1

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0;nb_init != 1 ;i++)
      nb_init/=2;
  return i;%}
xmax = inline_c %{
       int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
       int i;
       for(i = 0;i < d ;i++)
       	     nb_init = (nb_init+1)/2;
       return nb_init;%}

// Parallel partitioning
pui= inline_c %{ return (int) pow(2,d+1);%}
:A(k+(m*pui), n)
/*:BUFFER(m%Q,n)*/

// Parameters
READ  MYBUF <-  (d == 0)? MYBUF SWAP_COLLECT(k,descA.mt-((descA.mt-k-((m*2)+1))%P)-1,n) : MYBUF SWAP_SND(k,d-1,m*2,n)
            ->  ((m%2==0) && (d != dmax))? MYBUF SWAP_SND(k,d+1,m/2,n)
RW   BUFFER <-  ((d == 0) && (m == (((xmax+1)/2)-1)) && (xmax%2 == 1))? MYBUF SWAP_COLLECT(k,descA.mt-((descA.mt-k-((m*2)+1))%P)-1,n)
	    <-  (d == 0)? MYBUF SWAP_COLLECT(k,descA.mt-((descA.mt-k-((m*2)+2))%P)-1,n)
     	    <-  ((d != 0) && (m == (((xmax+1)/2)-1)) && (xmax%2 == 1))? BUFFER SWAP_SND(k,d-1,m*2,n)
     	    <-  (d != 0)? BUFFER SWAP_SND(k,d-1,m*2+1,n)
            ->  ((d != dmax) && (m%2==1))? BUFFER SWAP_SND(k,d+1,m/2,n)
	    ->  ((d != dmax) && (m == (((xmax+1)/2)-1)) && (((xmax+1)/2)%2 == 1))? BUFFER SWAP_SND(k,d+1,m/2,n)
            ->  (d == dmax)? B SWAP_PASTE(k,n)
READ     IP <-  (d == 0)? IP SWAP_COLLECT(k,descA.mt-((descA.mt-k-((m*2)+1))%P)-1,n) : IP SWAP_SND(k,d-1,m*2,n)           [type = PIVOT]
            ->  ((m%2==0) && (d != dmax))? IP SWAP_SND(k,d+1,m/2,n)                                                             [type = PIVOT]

//descA.mt-((descA.mt-1-k-m)%P)-1
//descA.mt-((descA.mt-2-k-m)%P)-1

;descA.mt-n-1

BODY
    DRYRUN(
/*        if(m<d)
        {
                ;
        }*/
          );

    printlog("SWAP_SND(k=%d,d=%d,m=%d,n=%d)\n",k,d,m,n);
END

/**************************************************
 *                    SWAP_PASTE
 * Updating the A(k,n)
 **************************************************/
SWAP_PASTE(k,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
n = k+1..descA.nt-1

d = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0;nb_init != 1 ;i++)
      nb_init/=2;
  return i;%}

// Parallel partitioning
:A(k,n)

// Parameters
CTL     ctl <-  ctl SWAP_COPY(k, n)
            ->  ctl TRSM_U(k,n)
READ      B <-  BUFFER SWAP_SND(k,d,0,n)

;descA.mt-n-1

BODY
    DRYRUN(
          );
    printlog("SWAP_PASTE(k=%d,n=%d)\n",d,n);
END

/**************************************************
 *                     TRSM_U                     *
 **************************************************/
TRSM_U(k, n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
n = k+1..descA.nt-1

// Parallel partitioning
: A(k, n)

// Parameters
READ    T <- T GETRF_FNL(k,k)
CTL   ctl <- ctl SWAP_PASTE(k,n)
RW      C <- A(k,n)/* B SWAP_PASTE(k,n) */
          -> B GEMM(k, k+1..descA.mt-1, n)
          -> A(k, n)

;descA.mt-n-1

BODY
        DRYRUN(
            int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
            int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
            int ldak = BLKLDD( descA, k );

            CORE_ztrsm(
                PlasmaLeft, PlasmaLower, PlasmaNoTrans, PlasmaUnit,
                tempkm,
                tempnn,
                (dague_complex64_t)1.0, T /*A(k, k)*/, ldak,
                                        C /*A(k, n)*/, ldak )
            );
        printlog("CORE_trsm_U(k=%d,n=%d,ldk=%d,A(%d,%d))\n", tempkm, tempnn,ldak,k,n);

END

/**************************************************
 *                      GEMM                      *
 **************************************************/
GEMM(k, m, n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-2:descA.nt-2)
m = k+1..descA.mt-1
n = k+1..descA.nt-1

// Parallel partitioning
: A(m, n)

// Parameters
READ  A <- T GETRF_FNL(k, m)
READ  B <- C TRSM_U(k, n)
RW    C <- T SWAP_RECV(k, m, n)
	  -> (n == k+1) ? T GETRF_MAX(k+1,m,0)  /* Panel */
        -> ((m == k+1) && (n >  k+1)) ? A SWAP_COPY(k+1,n)  /* Swap */
        -> ((m >  k)   && (n >  k+1)) ? T SWAP_COLLECT(k+1,m,n)  /* Everything else */

;descA.mt-n-1

BODY
    DRYRUN(
            int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
            int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
            int ldak = BLKLDD( descA, k );
            int ldam = BLKLDD( descA, m );

           CORE_zgemm(
                      PlasmaNoTrans, PlasmaNoTrans,
                      tempmm, tempnn, descA.mb,
                      (dague_complex64_t)-1.0, A /*A(m, k)*/, ldam,
                                               B /*A(k, n)*/, ldak,
                      (dague_complex64_t) 1.0, C /*A(m, n)*/, ldam )
          );
     printlog("CORE_gemm(k=%d,m=%d,n=%d,A(%d,%d),ldk=%d,ldm=%d)\n",k,tempmm,tempnn,m,n,ldak,ldam);
END
