extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"


%}

uplo [type = "PLASMA_enum"]
trans [type = "PLASMA_enum"]
alpha [type = "double"]
descA [type = "tiled_matrix_desc_t"]
A [type = "dague_ddesc_t *"]
beta [type = "double"]
descC [type = "tiled_matrix_desc_t"]
C [type = "dague_ddesc_t *"]


zherk(n,k)
  /* Execution space */
  n = 0..(descC.nt-1)
  k = 0..(descA.mt-1)

  : C(n,n)

  /* A == A(k,n) */
  /* B == C(n,n) */

  READ  A <- A zherk_in_A0(n,k)

  RW    B <- (0==k) ? C(n,n)
          <- (k>=1) ? B zherk(n, k-1)
          -> (descA.mt==(1+k)) ? C(n,n)
          -> (descA.mt>=(2+k)) ? B zherk(n, k+1)

  /*
  Anti-dependencies:

  */

BODY

  int tempnn = ((n)==(descC.nt-1)) ? (descC.n-(n*descC.nb)) : descC.nb;
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : descA.mb;
  int ldak = BLKLDD( descA, k );
  double dbeta = (k == 0 ) ? beta : (double)1.;
  int ldcn = BLKLDD( descC, n );

  DRYRUN(

    CORE_zherk(uplo, trans, tempnn,
        tempkm, alpha, A /* A(k,n) */,
        ldak, dbeta, B /* C(n,n) */,
        ldcn );  );

  printlog("CORE_zherk(%d, %d)\n"
           "\t(uplo, trans, tempnn, tempkm, alpha, A(%d,%d)[%p], ldak, dbeta, C(%d,%d)[%p], ldcn)\n",
  n, k, k, n, A, n, n, B);

END

/*
 * Pseudo-task
 */
zherk_in_A0(n,k) [profile = off]
  n = 0..(descC.nt-1)
  k = 0..(descA.mt-1)

  : A(k,n)

  RW A <- A(k,n)
       -> A zherk(n,k)
BODY
/* nothing */
END



zgemm(n,m,k1)
  /* Execution space */
  n = 0..inline_c %{ return dague_imin((descC.mt-2),(descC.nt-1)); %}
  m = (n+1)..(descC.mt-1)
  k1 = 0..(descA.mt-1)

  : C(n,m)

  /* C == A(k1,n) */
  /* D == A(k1,m) */
  /* E == C(n,m) */

  READ  C <- C zgemm_in_A0(n,m,k1)

  READ  D <- D zgemm_in_A1(n,m,k1)

  RW    E <- (0==k1) ? C(n,m)
          <- (k1>=1) ? E zgemm(n, m, k1-1)
          -> (descA.mt==(1+k1)) ? C(n,m)
          -> (descA.mt>=(2+k1)) ? E zgemm(n, m, k1+1)

  /*
  Anti-dependencies:

  */

BODY

  int tempnn = ((n)==(descC.nt-1)) ? (descC.n-(n*descC.nb)) : descC.nb;
  int tempmm = ((m)==(descC.mt-1)) ? (descC.m-(m*descC.mb)) : descC.mb;
  int tempkm = ((k1)==(descA.mt-1)) ? (descA.m-(k1*descA.mb)) : descA.mb;
  dague_complex64_t zalpha = (dague_complex64_t)alpha;
  int ldak = BLKLDD( descA, k1 );
  dague_complex64_t zbeta = (dague_complex64_t)( ( k1 == 0 ) ? beta : 1. );
  int ldcn = BLKLDD( descC, n );

  DRYRUN(

    CORE_zgemm(trans, PlasmaNoTrans, tempnn,
        tempmm, tempkm, zalpha,
        C /* A(k1,n) */, ldak, D /* A(k1,m) */,
        ldak, zbeta, E /* C(n,m) */,
        ldcn );  );

  printlog("CORE_zgemm(%d, %d, %d)\n"
           "\t(trans, PlasmaNoTrans, tempnn, tempmm, tempkm, zalpha, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldak, zbeta, C(%d,%d)[%p], ldcn)\n",
  n, m, k1, k1, n, C, k1, m, D, n, m, E);

END

/*
 * Pseudo-task
 */
zgemm_in_A0(n,m,k1) [profile = off]
  n = 0..inline_c %{ return dague_imin((descC.mt-2),(descC.nt-1)); %}
  m = (n+1)..(descC.mt-1)
  k1 = 0..(descA.mt-1)

  : A(k1,n)

  RW C <- A(k1,n)
       -> C zgemm(n,m,k1)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
zgemm_in_A1(n,m,k1) [profile = off]
  n = 0..inline_c %{ return dague_imin((descC.mt-2),(descC.nt-1)); %}
  m = (n+1)..(descC.mt-1)
  k1 = 0..(descA.mt-1)

  : A(k1,m)

  RW D <- A(k1,m)
       -> D zgemm(n,m,k1)
BODY
/* nothing */
END

