extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/dplasmajdf.h"

#if defined(HAVE_CUDA)
#include "gpu_data.h"
#include "dplasma/cores/cuda_zgemm.h"
extern int *gpu_counter;
#endif  /* defined(HAVE_CUDA) */
%}

/*
 * Globals
 */
transA [type = int]
transB [type = int]

alpha  [type = dague_complex64_t]
beta   [type = dague_complex64_t]

descA [type = "tiled_matrix_desc_t"]
A     [type = "dague_ddesc_t *"]
descB [type = "tiled_matrix_desc_t"]
B     [type = "dague_ddesc_t *"]
descC [type = "tiled_matrix_desc_t"]
C     [type = "dague_ddesc_t *"]

/**************************************************
 *                       READ_A                   *
 **************************************************/
READ_A(m, k)  [profile = off]

m = 0 .. descA.mt-1
k = 0 .. descA.nt-1

: A(m, k)

A <- A(m, k)
  -> A GEMM(m, 0, k)
BODY
    printlog("rank %u <- A(%d,%d)\n", __dague_object->super.A->myrank, m, k);
END

/**************************************************
 *                       READ_B                   *
 **************************************************/
READ_B(k, n)  [profile = off]

k = 0 .. descB.mt-1
n = 0 .. descB.nt-1

: B(k, n)

B <- B(k, n)
  -> B GEMM(0, n, k)
BODY
     printlog("rank %u <- B(%d,%d)\n", __dague_object->super.B->myrank, k, n);
END

/**************************************************
 *                       GEMM                     *
 **************************************************/
GEMM(m, n, k)

// Execution space
m = 0 .. descC.mt-1
n = 0 .. descC.nt-1
k = 0 .. descA.nt-1

// Parallel partitioning
: C(m, n)

// Parameters
READ A <- (n == 0)            ? A READ_A(m, k) : A GEMM( m, (n+descC.nt-1) % descC.nt, k )
       -> (n <= (descC.nt-2)) ? A GEMM( m, (n+1) % descC.nt, k )
READ B <- (m == 0)            ? B READ_B(k, n) : B GEMM( (m+descC.mt-1) % descC.mt, n, k )
       -> (m <= (descC.mt-2)) ? B GEMM( (m+1) % descC.mt, n, k )
RW   C <- (k == 0)            ? C(m, n) : C GEMM( m, n, k-1 )
       -> (k == (descA.nt-1)) ? C(m, n) : C GEMM( m, n, k+1 )
BODY
        dague_complex64_t lbeta = (k == 0) ? beta : (dague_complex64_t)1.0;
        int tempmm = m == descC.mt-1 ? descC.m - m * descC.mb : descC.mb;
        int tempnn = n == descC.nt-1 ? descC.n - n * descC.nb : descC.nb;
        int tempkk = k == descA.nt-1 ? descA.n - k * descA.nb : descA.nb;
        int ldam = BLKLDD(descA, m);
        int ldbk = BLKLDD(descB, k);
        int ldcm = BLKLDD(descC, m);

#if defined(HAVE_CUDA)
    if( dague_active_gpu() > 0 ) {
        int rc;

        if( 0 == (rc = gpu_zgemm( context, this_task, 
                                  ( n == k+1 ),
                                  transA, transB,
                                  tempmm, tempnn, tempkk,
                                  alpha, m, k, &descA, ldam,
                                         k, n, &descB, ldbk,
                                  lbeta, m, n, &descC, ldcm)) )
            goto FIN;
        if( -1 == rc ) {
            /* The task is pending in the device, and will be subsequently completed */
            return -1;
        }
        if( -2 == rc ) {
            /* The GPU failed to execute this task, but the task was already rescheduled */
	        fprintf(stderr, "Unable to disable GPU at runtime. Fatal error.\n");
	        exit(2);
        }
    }
    moesi_master_update( descC.super.moesi_map, GEMM_KEY( &descC, m, n) );
#endif  /* defined(HAVE_CUDA) */

        DRYRUN(
            CORE_zgemm(
                transA, transB,
                tempmm, tempnn, tempkk,
                alpha, A /*A(m, k)*/, ldam,
                       B /*B(k, n)*/, ldbk,
                lbeta, C /*C(m, n)*/, ldcm);
            );

        printlog("gemm( %d, %d, %d )\n"
                 "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n",
                 m, n, k,
                 plasma_const( transA ), plasma_const( transB ), 
                 tempmm, tempnn, tempkk,
                 creal(alpha), m, k, ldam,
                               k, n, ldbk,
                 creal(lbeta), m, n, ldcm );

#if defined(HAVE_CUDA)
FIN:
#endif  /* defined(HAVE_CUDA) */

END

extern "C" %{

%}
