extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */
  
#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "dplasma/lib/dplasmajdf.h"
%}

/* Globals
 * GRIDrows, GRIDcols, NB, SIZE
 */
side [type = int]
uplo [type = int]
trans[type = int]
diag [type = int]

alpha[type = Dague_Complex64_t]

Am   [type = int]
An   [type = int]
Amb  [type = int]
Anb  [type = int]
Amt  [type = int]
Ant  [type = int]

Bm   [type = int]
Bn   [type = int]
Bmb  [type = int]
Bnb  [type = int]
Bmt  [type = int]
Bnt  [type = int]
     
/**************************************************
 *                      TRMM                      *
 **************************************************/
TRMM_IN(m)  [profile = off]
m = 0..Bmt-1

: A(m, m)

READ A <- A(m, m)
       -> A TRMM(m, 0..Bnt-1)

BODY
  /* Nothing */
  printlog("thread %d trmm_in( %d )\n", context->eu_id, m);
END

TRMM(m, n)

// Execution space
m = 0..Bmt-1
n = 0..Bnt-1

// Parallel partitioning
: B(m, n)

// Parameters
READ  A   <- A TRMM_IN(m)
RW    B   <- B(m, n)
          -> (m == 0)     ? B(m, n)   : C GEMM(m, n, m-1)
CTL   ctl <- (m != Bmt-1) ? ctl1 GOK(m+1, n, m)

BODY
     int tempmm = m == Bmt-1 ? Bm - m * Bmb : Bmb;
     int tempnn = n == Bnt-1 ? Bn - n * Bnb : Bnb;
     DRYRUN(
	  CORE_ztrmm(
              side, uplo, trans, diag,
              tempmm, tempnn,
              alpha, A /*A(m, m)*/, Amb,
                     B /*B(m, n)*/, Bmb)
          );

     printlog("thread %d CORE_ztrmm( %d, %d )\n"
              "    ( %s, %s, %s, %s, %d, %d, %f, A(%d,%d)[%p], %d, B(%d,%d)[%p], %d)\n",
              context->eu_id, m, n, 
              plasma_const(side), plasma_const(uplo), plasma_const(trans), plasma_const(diag), 
              tempmm, tempnn,
              creal(alpha), m, m, A, Amb,
                     m, n, B, Bmb);
END

/**************************************************
 *                      GEMM                      *
 **************************************************/
GEMM_INA(m, k)  [profile = off]
m = 0..Bmt-1
k = 0..m-1

:A(m, k)

READ A <- A(m, k)
       -> A GEMM(m, 0..Bnt-1, k)

BODY
  /* Nothing */
  printlog("thread %d gemm_inA( %d, %d )\n", context->eu_id, m, k);
END


GEMM_INB(k, n)  [profile = off]
k = 0..Bmt-2
n = 0..Bnt-1

:B(k, n)

READ B <- B(k, n)
       -> B GEMM(k+1..Bmt-1, n, k)

BODY
  /* Nothing */
  printlog("thread %d gemm_inB( %d, %d )\n", context->eu_id, k, n);
END

// Name
GEMM(m, n, k)

// Execution space
m = 0..Bmt-1
n = 0..Bnt-1
k = 0..m-1

// Parallel partitioning
: B(m, n)

// Parameters
READ  A   <- A GEMM_INA(m, k)
READ  B   <- B GEMM_INB(k, n) 
RW    C   <- (k == m-1) ? B TRMM(m, n) : C GEMM(m, n, k+1)
          -> (k == 0)   ? B(m, n)      : C GEMM(m, n, k-1)
CTL   ctl -> ctl2 GOK(m, n, k)
BODY
     int tempmm = m == Bmt-1 ? Bm - m * Bmb : Bmb;
     int tempnn = n == Bnt-1 ? Bn - n * Bnb : Bnb;
     DRYRUN(
            CORE_zgemm(
		  trans, PlasmaNoTrans,
                  tempmm, tempnn, Bmb,
		  alpha, A, Amb,
		         B, Bmb,
		  (Dague_Complex64_t)1.0, C, Bmb)
	   );

      printlog("thread %d gemm( %d, %d, %d )\n"
	       "    ( %s, %s, %d, %d, %d, %f, A(%d,%d)[%p], %d, B(%d,%d)[%p], %d, %f, B(%d,%d)[%p], %d)\n",
	       context->eu_id, m, n, k, 
               plasma_const(trans), plasma_const( PlasmaNoTrans ), 
               tempmm, tempnn, Bmb,
	       creal(alpha), m, k, A, Bmb, k, n, B, Bmb,
	       (Dague_Complex64_t)1.0, m, n, C, Bmb);
END

/**************************************************
 *                      GOK                       *
 **************************************************/
// Name
GOK(m, n, k)  [profile = off]

// Execution space
m = 0..Bmt-1
n = 0..Bnt-1
k = 0..m-1

// Parallel partitioning
: B(m, n)

// Parameters
CTL   ctl1 <- (m != Bmt-1) ? ctl1 GOK(m+1, n, k)
           -> (m-1 == k)   ? ctl TRMM(k, n) : ctl1 GOK(m-1, n, k)
CTL   ctl2 <- ctl GEMM(m, n, k)
BODY
      /* Fake task to guaranty the end of all gemm using B(m, n) before to start TRMM */
     printlog("thread %d gok( %d, %d, %d )\n", context->eu_id, m, n, k);
END
