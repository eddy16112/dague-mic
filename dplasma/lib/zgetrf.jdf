extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */
#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_dist/matrix/matrix.h"
#include "memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"

#if (PLASMA_VERSION_MAJOR <= 2) && (PLASMA_VERSION_MINOR <= 2)
#define CORE_zssssm(M1, N1, M2, N2, K, IB, A1, LDA1, A2, LDA2, L1, LDL1, L2, LDL2, IPIV) \
        CORE_zssssm(M1,     M2, N2, IB, K, A1, LDA1, A2, LDA2, L1, LDL1, L2, LDL2, IPIV)
#endif

#if (PLASMA_VERSION_MAJOR >= 2) && (PLASMA_VERSION_MINOR >= 4)
#define CORE_zgetrf CORE_zgetrf_incpiv
#endif

%}

/** Globals */
A
L         [aligned = A]
IPIV      [aligned = A]
work_pool [type = "dague_memory_pool_t*"]
INFO      [type = "int*"]

/* 
 * Parameters
 */
ib   [type = int]

Am   [type = int]
An   [type = int]
Amb  [type = int]
Anb  [type = int]
Amt  [type = int]
Ant  [type = int]

Lmb  [type = int]
Lnb  [type = int]

/************************************************************************************
 *                                    GETRF                                         *
 ************************************************************************************/
zgetrf_out(k)  [profile = off]
k = 0..( (Amt < Ant) ? Amt-1 : Ant-1 )

  :A(k, k)

  READ A <- A zgetrf(k)
         -> (Ant>=(k+2)) ? D zgessm(k, (k+1)..(Ant-1))         [type = LOWER_TILE]
         -> (Amt==(k+1)) ? A(k,k)
  READ B <- B zgetrf(k)                                        [type = PIVOT]
         -> (Ant>=(k+2)) ? C zgessm(k, (k+1)..(Ant-1))         [type = PIVOT]
         -> IPIV(k,k)                                          [type = PIVOT]
  
BODY
        /* Nothing */
        printlog("thread %d zgetrf_out( %d )\n",
                 context->eu_id, k);
END

zgetrf(k)
  /* Execution space */
  k = 0..( (Amt < Ant) ? Amt-1 : Ant-1 )

  /* A == A(k,k) */
  /* B == IPIV(k,k) */
  /* C == IPIV(k,k) */
  /* D == A(k,k) */
  /* F == A(k,k) */
  /* K == A(m,n1) */

  /* Locality */
  :A(k, k)

  RW    A <- ( 0 == k ) ? A(k,k) : K zssssm(k-1, k, k) 
          -> (Amt>=(k+2)) ? F ztstrf(k, k+1)                    [type = UPPER_TILE] 
          -> A zgetrf_out(k)
          /* Do the next two lines to split the two different types in two tasks */
          /* -> (Ant>=(k+2)) ? D zgessm(k, (k+1)..(Ant-1))         [type = LOWER_TILE] */
          /* -> (Amt==(k+1)) ? A(k,k) */
  RW    B <- IPIV(k,k)                                          [type = PIVOT]
          -> B zgetrf_out(k)                                    [type = PIVOT]
          /* -> IPIV(k,k)                                          [type = PIVOT] */
          /* -> (Ant>=(k+2)) ? C zgessm(k, (k+1)..(Ant-1))         [type = PIVOT] */

  /* Priority */
  ;(Ant-k)*(Ant-k)*(Ant-k)

BODY

  int iinfo = 0;
  DRYRUN(
         int tempkm = ((k)==(Amt-1)) ? (Am-(k*Amb)) : (Amb);
         int tempkn = ((k)==(Ant-1)) ? (An-(k*Anb)) : (Anb);
         int ldak   = Amb; /*((k+(Ai/Amb))<Alm1) ? (Amb) : (Alm%Bmb);*/

         CORE_zgetrf(tempkm, tempkn, ib, 
                     A /* A(k,k) */, ldak, 
                     B /* IPIV(k,k) */, &iinfo );
         if ( (iinfo != 0) && (k == Amt-1) )
           *INFO = k * Amb + iinfo; /* Should return if enter here */
         );

  printlog("thread %d   CORE_zgetrf(%d)\n\t(tempkm, tempkn, ib, A(%d,%d)[%p], ldak, IPIV(%d,%d)[%p]) => info = %d\n",
           context->eu_id, k, k, k, A, k, k, B, k * Amb + iinfo);

END


/************************************************************************************
 *                                    GESSM                                         *
 ************************************************************************************/
zgessm(k,n)
  /* Execution space */
  k = 0..( (Amt < Ant) ? Amt-1 : Ant-1 )
  n = k+1..Ant-1

  /* A == A(k,k) */
  /* B == IPIV(k,k) */
  /* C == IPIV(k,k) */
  /* D == A(k,k) */
  /* E == A(k,n) */
  /* J == A(k,n1) */
  /* K == A(m,n1) */

  /* Locality */
:A(k, n)

  READ  C <- B zgetrf_out(k)                                        [type = PIVOT]                      
  READ  D <- A zgetrf_out(k)                                        [type = LOWER_TILE]
  RW    E <- (0==k) ? A(k,n) : K zssssm(k-1, k-1+1, n)          
          -> (Amt==(k+1)) ? A(k,n)
          -> (Amt>=(k+2)) ? J zssssm(k, k+1, n) 

    /* Priority */
; (Amt-k)*(Amt-n)*(Amt-n)

BODY

  DRYRUN(
         int tempnn = ((n)==(Ant-1)) ? (An-(n*Anb)) : (Anb);
         int tempkm = ((k)==(Amt-1)) ? (Am-(k*Amb)) : (Amb);
         int ldak   = Amb; /*((k+(Ai/Amb))<Alm1) ? (Amb) : (Alm%Amb);*/

         CORE_zgessm(tempkm, tempnn, tempkm, ib, 
                     C /* IPIV(k,k) */, 
                     D /* A(k,k) */, ldak, 
                     E /* A(k,n) */, ldak );
         );
   printlog("thread %d   CORE_zgessm(%d, %d)\n\t(tempkm, tempnn, tempkm, ib, IPIV(%d,%d)[%p], A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldak)\n",
            context->eu_id, k, n, k, k, C, k, k, D, k, n, E);

END

/************************************************************************************
 *                                    TSTRF                                         *
 ************************************************************************************/
ztstrf_out(k)  [profile = off]
k = 0..( (Amt <= Ant) ? Amt-2 : Ant-1 )

:A(k, k)

  READ A <- F ztstrf(k, Amt-1)       [type = UPPER_TILE]
         -> A(k, k)                  [type = UPPER_TILE]

BODY
        /* Nothing */
        printlog("thread %d ztstrf_out( %d )\n", 
                 context->eu_id, k);
END

ztstrf(k,m)
  /* Execution space */
  k = 0..( (Amt < Ant)? Amt-1 : Ant-1 )
  m = k+1..Amt-1

  /* A == A(k,k) */
  /* F == A(k,k) */
  /* G == A(m,k) */
  /* H == L(m,k) */
  /* I == IPIV(m,k) */
  /* K == A(m,n1) */
  /* L == L(m,k) */
  /* M == A(m,k) */
  /* N == IPIV(m,k) */

  /* Locality */
:A(m, k)

  RW    F <- ((k+1)==m) ? A zgetrf(m-1) : F ztstrf(k, m-1)   [type = UPPER_TILE]
          -> (Amt>=(m+2)) ? F ztstrf(k, m+1)                 [type = UPPER_TILE]
          -> (Amt==(m+1)) ? A ztstrf_out(k)                  [type = UPPER_TILE]
  RW    G <- (0==k) ? A(m,k) :  K zssssm(k-1, m, k) 
          -> (Ant>=(k+2)) ? M zssssm(k, m, (k+1)..(Ant-1)) 
          -> A(m,k)                                          
  RW    H <- L(m,k)                                          [type = SMALL_L]
          -> L(m,k)                                          [type = SMALL_L]
          -> (Ant>=(k+2)) ? L zssssm(k, m, (k+1)..(Ant-1))   [type = SMALL_L]
  RW    IP<- IPIV(m,k)                                       [type = PIVOT]
          -> IPIV(m,k)                                       [type = PIVOT]
          -> (Ant>=(k+2)) ? N zssssm(k, m, (k+1)..(Ant-1))   [type = PIVOT]

    /* Priority */
; (Amt-k)*(Amt-k)*(Amt-k)

BODY

  DRYRUN(
         int tempmm = ((m)==(Amt-1)) ? (Am-(m*Amb)) : (Amb);
         int tempkn = ((k)==(Ant-1)) ? (An-(k*Anb)) : (Anb);
         int ldak   = Amb; /*((k+(Ai/Amb))<Alm1) ? (Amb) : (Alm%Amb);*/
         int ldam   = Amb; /*((m+(Ai/Amb))<Alm1) ? (Amb) : (Alm%Amb);*/

         int iinfo;
         PLASMA_Complex64_t *work = dague_private_memory_pop(work_pool);

         CORE_ztstrf(tempmm, tempkn, ib, Lnb, 
                     F /* A(k,k) */, ldak, 
                     G /* A(m,k) */, ldam, 
                     H /* L(m,k) */, Lmb, 
                     IP /* IPIV(m,k) */, 
                     work, Lnb, &iinfo );
         dague_private_memory_push(work_pool, work);

         if ( (iinfo != 0) && (m == Amt-1) )
           *INFO = k * Amb + iinfo; /* Should return if enter here */
         );

  printlog("thread %d   CORE_ztstrf(%d, %d)\n\t(tempmm, tempkn, ib, Lnb, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldam, L(%d,%d)[%p], Lmb, IPIV(%d,%d)[%p], Lnb)\n",
           context->eu_id, k, m, k, k, F, m, k, G, m, k, H, m, k, IP);

END

/************************************************************************************
 *                                    SSSSM                                         *
 ************************************************************************************/
zssssm_out(k, n1)  [profile = off]
k = 0..( (Amt < Ant)? Amt-2 : Ant-2 )
n1 = k+1..Ant-1

:A(k, n1)

  READ A <- J zssssm(k, Amt-1, n1)
         -> A(k, n1)

BODY
        /* Nothing */
        printlog("thread %d zssssm_out( %d, %d )\n", 
                 context->eu_id, k, n1);
END

zssssm(k,m,n1)
  /* Execution space */
  k = 0..( (Amt < Ant) ? Amt-1 : Ant-1 )
  m = k+1..Amt-1
  n1 = k+1..Ant-1

  /* A == A(k,k) */
  /* E == A(k,n) */
  /* G == A(m,k) */
  /* H == L(m,k) */
  /* I == IPIV(m,k) */
  /* J == A(k,n1) */
  /* K == A(m,n1) */
  /* L == L(m,k) */
  /* M == A(m,k) */
  /* N == IPIV(m,k) */

  /* Locality */
:A(m, n1)

  RW    J <- ((k+1)==m) ? E zgessm(m-1, n1) : J zssssm(k, m-1, n1)
          -> (Amt>=(m+2)) ? J zssssm(k, m+1, n1)
          -> (Amt==(m+1)) ? A zssssm_out(k,n1)
  RW    K <- (0==k) ? A(m,n1) : K zssssm(k-1, m, n1)
          -> ((1+k)==n1) & (Amt>=(k+2)) & (m>=(k+2))   ? G ztstrf(n1, m)
          -> ((1+k)==n1) & ((k+1)==m)   & (Amt>=(k+2)) ? A zgetrf(n1)
          -> ( m==(k+1)) & (n1>=(m+1)) ? E zgessm(k+1, n1)
          -> (n1>=(k+2)) & (m >=(k+2)) ? K zssssm(k+1, m, n1)
  READ  L <- H ztstrf(k, m)                                               [type = SMALL_L]
  READ  M <- G ztstrf(k, m)
  READ  N <- IP ztstrf(k, m)                                              [type = PIVOT]

    /* Priority */
; (Amt-k)*(Amt-n1)*(Amt-n1)

BODY

  int tempmm = ((m) ==(Amt-1)) ? (Am -( m*Amb)) : (Amb);
  int tempnn = ((n1)==(Ant-1)) ? (An -(n1*Anb)) : (Anb);
  int ldak   = Amb; /*((k+(Ai/Amb))<Alm1) ? (Amb) : (Alm%Amb);*/
  int ldam   = Amb; /*((m+(Ai/Amb))<Alm1) ? (Amb) : (Alm%Amb);*/

  DRYRUN(
         CORE_zssssm(Anb, tempnn, tempmm, tempnn, Anb, ib, 
                     J /* A(k,n1) */, ldak, 
                     K /* A(m,n1) */, ldam, 
                     L /* L(m,k) */,  Lmb, 
                     M /* A(m,k) */,  ldam, 
                     N /* IPIV(m,k) */ );
         );
  printlog("thread %d   CORE_zssssm(%d, %d, %d)\n\t(%d, %d, %d, %d, %d, %d, A(%d,%d)[%p], %d, A(%d,%d)[%p], %d, L(%d,%d)[%p], %d, A(%d,%d)[%p], %d, IPIV(%d,%d)[%p])\n",
           context->eu_id, k, m, n1, Anb, tempnn, tempmm, tempnn, Anb, ib, k, n1, J, ldak, m, n1, K, ldam, m, k, L, Lmb, m, k, M, ldam, m, k, N);

END
