extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"

#define max_thrdnbr_per_panel 8
#define nbthreads( __k ) (dague_imin( ((descA.mt - (__k)) + 3 )/  4, max_thrdnbr_per_panel) - 1)

%}

/** Globals */
descA     [type = "tiled_matrix_desc_t"]
A         [type = "dague_ddesc_t *"]
IPIV      [type = "dague_ddesc_t *"]
INFO      [type = "int*"]

/************************************************************************************
 *                      Tiles 2 panel (Reduction version)
 *
 *  All Gemm from step k-1 on panel n have to be finished before
 *  to apply getrf or swptrsm on panel n
 ************************************************************************************/
/* tile2panel(k, n) [profile = off] */
/* k = 1..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 ) */
/* n = k..descA.nt-1 */

/* :A(k, n) */

/* CTL  ctl <- ctlf gemm(k-1, k..descA.mt-1, n) */
/*          -> (n == k ) ? ctl getrf(k) : ctl swptrsm(k, n) */

/************************************************************************************
 *                      Tiles 2 panel (Forward)                                     *
 ************************************************************************************/
tile2panel(k, m, n) [profile = off]
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-2 )
  m = k+1..descA.mt-1
  n = k+1..descA.nt-1
  ntrd = inline_c %{ return nbthreads( k+1 ); %}

  :A(k, n)

  CTL  ctl1 <- ctl gemm(k, m, n)
  CTL  ctl2 <- (m > k+1        ) ? ctl2 tile2panel(k, m-1, n)
            -> (m < descA.mt-1 )  ? ctl2 tile2panel(k, m+1, n)
            -> ((m == descA.mt-1 ) && (n == k+1)) ? ctl  getrf(k+1, 0..ntrd)
            -> ((m == descA.mt-1 ) && (n >  k+1)) ? ctl  swptrsm(k+1, n)
            -> (( m == descA.mt-1) && (k > 0 )) ? ctl1 subm2panel(k, n)

  ;n
BODY
    printlog("thread %d tile2panel( %d, %d, %d )\n", context->eu_id, k, m, n);
END

/************************************************************************************
 *                    Submatrix 2 panel (backward)
 *
 * All the GEMM applied to the submatrix at step k-1 have to performed
 * before to do backward substitution from step k on previous panel
 *
 ************************************************************************************/
/* subm2panel(k, n) [profile = off] */
/* k = 1..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 ) */

/* :A(k, k-1) */

/* CTL  ctl1 <- ctlb gemm(k-1, k..descA.mt-1, k+1..descA.nt-1) */
/*           -> ctl swpback(k, k-1) */
/* BODY */
/*      printlog("thread %d tile2panel( %d, %d, %d )\n", context->eu_id, m, n, k); */
/* END */

/************************************************************************************
 *                    Submatrix 2 panel (backward)                                  *
 ************************************************************************************/
subm2panel(k, n) [profile = off]
  k = 1..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-2 )
  n = k+1..descA.nt-1

  :A(k, n)

  CTL  ctl1 <- ctl2 tile2panel(k, descA.mt-1, n)
  CTL  ctl2 <- (n > k+1) ? ctl2 subm2panel(k, n-1)
            -> (n < descA.nt-1) ? ctl2 subm2panel(k, n+1) : ctl swpback(k, k-1)

BODY
    printlog("thread %d subm2panel( %d, %d )\n", context->eu_id, k, n);
END

/************************************************************************************
 *                                    GETRF                                         *
 ************************************************************************************/

getrf(k, t)
  /* Execution space */
  k  = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  t  = 0..inline_c %{ return nbthreads( k ); %}
  m1 = inline_c %{ return k + t * 4; %}
  m2 = inline_c %{ return dague_imin( k + (t+1) * 4 - 1, descA.mt-1); %}

  /* Locality */
  :A(k, k)

  RW    A    <- ( 0 == k ) ? A(k, k) : C gemm(k-1, k, k)
          /* <- A(m1..m2, k) : C gemm(k-1, m1..m2, k) */
             -> ((k < descA.nt-1) && (t == 0)) ? A swptrsm(k, k+1..descA.nt-1)
             -> (t == 0) ? A(k, k)
          /* -> A(m1..m2, k) */
  RW    IPIV <- IPIV(k,0)                                                        [type = PIVOT]
             -> IPIV(k,0)                                                        [type = PIVOT]
             -> ((t==0) && (k < descA.nt-1)) ? IPIV swptrsm(k, k+1..descA.nt-1)  [type = PIVOT]
             -> ((t==0) && (k > 0)         ) ? IPIV swpback(k, 0..k-1)           [type = PIVOT]
  CTL   ctl  <- (k > 0) ? ctl2 tile2panel(k-1, descA.mt-1, k)
  /*  CTL   ctl  <- (k > 0) ? ctl2 tile2panel(k-1, m2,         k)*/

/* Priority */
;k

BODY

  int tempm  = descA.m - k * descA.mb;
  int tempkn = k == descA.nt-1 ? descA.n-k*descA.nb : descA.nb;
  int ldak = BLKLDD(descA, k);

  DRYRUN(
      int tempkm = k == descA.mt-1 ? descA.m-k*descA.mb : descA.mb;
      int nbthreads = nbthreads( k );
      int info[3];

      /* Set local IPIV to 0 before generation
       * Better here than a global initialization for locality
       * and it's also done in parallel */
      if ( t == 0 ) {
          memset(IPIV, 0, dague_imin(tempkn, tempkm) * sizeof(int) );
          fprintf(stderr, "Ther are %d threads woking on it\n", nbthreads);
      }

      info[1] = t;
      info[2] = nbthreads+1;

      CORE_zgetrf_reclap(
          tempm, tempkn,
          A/*(k, k)*/, ldak, IPIV, info );

      if ( (t == 0) && (info[0] != PLASMA_SUCCESS) ) {
          *INFO = k * descA.mb + info[0]; /* Should return if enter here */
          fprintf(stderr, "zgetrf(%d) failed => %d\n", k, *INFO );
      }
         );

   printlog("thread %d   CORE_zgetrf_rec(%d)\n"
            "\t(%d, %d, A(%d,%d)[%p], %d, IPIV(%d)[%p])\n",
            context->eu_id, k, tempm, tempkn, k, k, A, ldak, k, IPIV);

END


/************************************************************************************
 *                              SWAP + TRSM                                         *
 ************************************************************************************/

swptrsm(k, n)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-2 )
  n = k+1..descA.nt-1

  /* Locality */
  :A(k, n)

  READ  A    <- A    getrf(k, 0)
  READ  IPIV <- IPIV getrf(k, 0)                                [type = PIVOT]
  RW    B    <- ( 0 == k ) ? A(k,n) : C gemm(k-1, k, n)
          /* <- A(k..descA.mt-1, n) : C gemm(k-1, k..descA.mt-1, n) */
             -> (k < descA.mt-1) ? B gemm(k, k+1..descA.mt-1, n)
             -> A(k, n)
  CTL   ctl  <- ( k > 0 ) ? ctl2 tile2panel(k-1, descA.mt-1, n)

/* Priority */
;n

BODY

  DRYRUN(
         int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
         int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
         int ldak = BLKLDD(descA, k);

         CORE_zlaswp( tempnn, B, descA.lm, 1, tempkm, IPIV, 1);

         CORE_ztrsm(
             PlasmaLeft, PlasmaLower, PlasmaNoTrans, PlasmaUnit,
             tempkm, tempnn,
             1., A /*(k, k)*/, ldak,
                 B /*(k, n)*/, ldak);
         );

   printlog("thread %d   CORE_zswptrsm(%d, %d)\n"
            "\t(%d, %d, A(%d,%d)[%p], B(%d,%d)[%p])\n",
            context->eu_id, k, n, tempkm, tempnn, k, k, A, k, n, B);

END

/************************************************************************************
 *                                    GEMM                                         *
 ************************************************************************************/
gemm(k,m,n)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-2 : descA.nt-2 )
  m = k+1..descA.mt-1
  n = k+1..descA.nt-1
  ntrd = inline_c %{ return nbthreads( k+1 ); %}

  /* Locality */
:A(m, n)

  READ  A  <- A(m, k)
  READ  B  <- B swptrsm(k, n)
  RW    C  <- ( k   == 0 ) ? A(m, n) : C gemm(k-1, m, n)
           -> ( k+1 == n ) && ( k+1 == m ) ? A getrf(k+1, 0..ntrd)
         /*-> ( k+1 == n ) && ( k+1 != m ) ? A getrf(k+1)*/
           -> ( k+1 <  n ) && ( k+1 == m ) ? B swptrsm(k+1, n)
           -> ( k+1 <  n ) && ( k+1 <  m ) ? C gemm(k+1, m, n)
  CTL  ctl -> ctl1 tile2panel(k, m, n)

    /* Priority */
; n

BODY

  DRYRUN(
      int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
      int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
      int ldak = BLKLDD(descA, k);
      int ldam = BLKLDD(descA, m);

      CORE_zgemm(PlasmaNoTrans, PlasmaNoTrans,
                 tempmm, tempnn, descA.mb,
                 -1., A /*(m, k)*/, ldam,
                      B /*(k, n)*/, ldak,
                 1.,  C /*(m, n)*/, ldam );
         );
   printlog("thread %d   CORE_zgemm(%d, %d, %d)\n"
            "\t(%d, %d, %d, A(%d,%d)[%p], %d, B(%d,%d)[%p], %d, C(%d,%d)[%p], %d)\n",
            context->eu_id, k, m, n, tempmm, tempnn, descA.mb, k, k, A, ldam, k, k, B, ldak, k, n, C, ldam);

END

/************************************************************************************
 *                              SWAP Backward                                       *
 ************************************************************************************/

swpback(k, n)
  /* Execution space */
  k = 1..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  n = 0..k-1

  /* Locality */
  :A(k, n)

  READ  IPIV <- IPIV getrf(k, 0)                                [type = PIVOT]
  RW    A    <- A(k, n)
             -> A(k, n)
  CTL   ctl  <- ((k < descA.nt-1) && (n == k-1)) ? ctl2 subm2panel(k, descA.nt-1)
             <- (n <  k-1)                                ? ctl swpback(k-1, n)
             -> (( k < descA.nt-1 ) && (k < descA.mt-1 )) ? ctl swpback(k+1, n)

/* Priority */
; descA.nt
BODY

  DRYRUN(
      int tempkm = k == descA.mt-1 ? descA.m-k*descA.mb : descA.mb;
      int tempkn = k == descA.nt-1 ? descA.n-k*descA.nb : descA.nb;
      int tempk  = dague_imin(tempkn, tempkm);
      int ldak = BLKLDD(descA, k);

      CORE_zlaswp( descA.nb, A/*(k, n)*/, ldak, 1, tempk, IPIV, 1 );
         );

  printlog("thread %d CORE_zswpback(%d, %d)\n"
           "\t(%d, A(%d,%d)[%p], %d, IPIV(%d)[%p])\n",
           context->eu_id, k, n, descA.nb, k, n, A, ldak, k, IPIV);

END
