extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */
#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_distribution.h"
#include "memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"

#include "data_dist/sparse-matrix/pastix_internal/pastix_internal.h"
#include "data_dist/sparse-matrix/sparse-matrix.h"

#define PRECISION_z

void core_zsytrfsp1d(Dague_Complex64_t *L,
                     Dague_Complex64_t *work,
                     SolverMatrix *datacode,
                     dague_int_t c);

void core_zsytrfsp1d_gemm(dague_int_t cblknum,
                          dague_int_t bloknum,
                          dague_int_t fcblknum,
                          Dague_Complex64_t *L,
                          Dague_Complex64_t *C,
                          Dague_Complex64_t *work1,
                          Dague_Complex64_t *work2,
                          SolverMatrix *datacode);
%}

/* Globals
 */
descA    [type = "sparse_matrix_desc_t *"]
A        [type = "dague_ddesc_t *"]
datacode [type = "SolverMatrix*" default="&(descA->pastix_data->solvmatr)" hidden=on]
cblknbr  [type = "dague_int_t"   default="descA->pastix_data->solvmatr.symbmtx.cblknbr" hidden=on]
bloknbr  [type = "dague_int_t"   default="descA->pastix_data->solvmatr.symbmtx.bloknbr" hidden=on]
p_work1  [type = "dague_memory_pool_t *" size = "datacode->coefmax * sizeof(Dague_Complex64_t)"]
p_work2  [type = "dague_memory_pool_t *" size = "datacode->coefmax * sizeof(Dague_Complex64_t)"]

/**************************************************
 *                POTRF_TRSM                      *
 **************************************************/
POTRF_TRSM(k) [high_priority = on]

// Execution space
k = 0..cblknbr-1
browk     = inline_c %{ return UPDOWN_LISTPTR( UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( k ))   ); %}
browk1    = inline_c %{ return UPDOWN_LISTPTR( UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( k ))+1 ); %}
lastbrow  = inline_c %{ if (browk1 > 0) return UPDOWN_LISTBLOK(browk1-1); else return 0; %}
firstblok = inline_c %{ return SYMB_BLOKNUM(k); %}
lastblok  = inline_c %{ return SYMB_BLOKNUM(k+1); %}
// Parallel partitioning
:A(k) // Should match SOLV_COEFTAB(k)

// Parameters
/* C is A(k) if it's a leaf or get the cblk from the last update */
RW A <- ( browk == browk1 ) ? A(k) : C GEMM( lastbrow )
     -> A GEMM(firstblok+1..lastblok-1)
     -> A(k)

BODY
      Dague_Complex64_t *work = (Dague_Complex64_t *)dague_private_memory_pop( p_work1 );
      DRYRUN(
             core_zsytrfsp1d(A, work, datacode, k);
	     );
      printlog(
               "thread %d compute_1dplus( cblknum=%d, browk=%d, browk1=%d, lastbrow=%d, firstblok=%d, lastblok=%d )\n",
               context->eu_id, k, browk, browk1, lastbrow, firstblok, lastblok);

      dague_private_memory_push( p_work1, (void *)work );
END

/**************************************************
 *                      GEMM                      *
 **************************************************/

GEMM(k)

// Execution space
k = 0..bloknbr-2
fcblk  = inline_c %{ return SYMB_CBLKNUM(k); %}
cblk   = inline_c %{ return sparse_matrix_get_lcblknum( descA, (dague_int_t)k ); %}// TODO: store cblknum in symbblok
phony  = inline_c %{ return k == SYMB_BLOKNUM( cblk ); %}
prev   = inline_c %{ if (phony) return 0; else return sparse_matrix_get_listptr_prev( descA, (dague_int_t)k, (dague_int_t)fcblk ); %}
next   = inline_c %{ if (phony) return 0; else return sparse_matrix_get_listptr_next( descA, (dague_int_t)k, (dague_int_t)fcblk ); %}

// Parallel partitioning
:A(fcblk)

// Parameters
READ  A <- phony ? A(fcblk) : A POTRF_TRSM(cblk)
RW    C <- ( prev == 0 ) ? A(fcblk) : C GEMM( prev )
        -> phony ? A(fcblk)
        -> ((!phony) && (next == 0)) ? A POTRF_TRSM( fcblk )
        -> ((!phony) && (next != 0)) ? C GEMM( next )

BODY
      Dague_Complex64_t *work1 = (Dague_Complex64_t *)dague_private_memory_pop( p_work1 );
      Dague_Complex64_t *work2 = (Dague_Complex64_t *)dague_private_memory_pop( p_work2 );

      if (!phony) {
      DRYRUN(
             core_zsytrfsp1d_gemm(cblk, k, fcblk, A, C, work1, work2, datacode);
          );
      printlog(
               "thread %d compute_1dgemm( k=%d, fcblk=%d, cblk=%d, prev=%d, next=%d )\n",
               context->eu_id, k, fcblk, cblk, prev, next);
      } else {
      printlog(
               "thread %d phony_gemm( k=%d, fcblk=%d, cblk=%d, prev=%d, next=%d )\n",
               context->eu_id, k, fcblk, cblk, prev, next);
      }

      dague_private_memory_push( p_work1, (void *)work1 );
      dague_private_memory_push( p_work2, (void *)work2 );
END
