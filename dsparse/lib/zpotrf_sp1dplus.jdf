extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */
#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_distribution.h"
#include "dplasmajdf.h"
#include "data_dist/sparse_matrix/sparse_matrix.h"

#include "sopalin_acces.h"

#define PRECISION_z

%}

/* Globals
 */
descA    [type = "sparse_matrix_desc_t *"]
A        [type = "dague_ddesc_t *"]
datacode [type = "SolverMatrix*"]
cblknbr  [type = "dague_int_t" default="SYMB_CBLKNBR" hidden=on]
bloknbr  [type = "dague_int_t" default="SYMB_BLOKNBR" hidden=on]


/**************************************************
 *                POTRF_TRSM                      *
 **************************************************/
POTRF_TRSM(k) [high_priority = on]

// Execution space
k = 0..cblknbr-1
browk  = inline_c %{ return UPDOWN_LISTPTR( UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( k ))   ); %}
browk1 = inline_c %{ return UPDOWN_LISTPTR( UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( k ))+1 ); %}
bloknum= inline_c %{ return UPDOWN_LISTBLOK(browk1-1); %}
firstblok = inline_c %{ return SYMB_BLOKNUM(k); %}
lastblok  = inline_c %{ return SYMB_BLOKNUM(k+1); %}
// Parallel partitioning
:A(k) // Should match SOLV_COEFTAB(k)

// Parameters
/* C is A(k) if it's a leaf or get the cblk from the last update */
RW C <- ( browk == browk1 ) ? A(k) : C GEMM( bloknum )
     -> C GEMM(firstblok..lastblok-1)
     -> A(k)

BODY
      DRYRUN(
	     /* compute_1dplus */
	     );
      printlog(
               "thread %d compute_1dplus( %d )\n",
               context->eu_id, k);
END

/**************************************************
 *                      GEMM                      *
 **************************************************/

GEMM(k)

// Execution space
k = 0..bloknbr-1
fcblk  = inline_c %{ return SYMB_CBLKNUM(k); %}
cblk   = inline_c %{ return sparse_matrix_get_lcblknum( descA, k ); %}// TODO: store cblknum in symbblok
browk  = inline_c %{ return UPDOWN_LISTPTR( UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( fcblk ))   ); %}
browk1 = inline_c %{ return UPDOWN_LISTPTR( UPDOWN_GCBLK2LIST(UPDOWN_LOC2GLOB( fcblk ))+1 ); %}
prev   = inline_c %{ return sparse_matrix_get_listptr_prev( k, fcblk ); %}
next   = inline_c %{ return sparse_matrix_get_listptr_next( k, fcblk ); %}

// Parallel partitioning
:A(fcblk)

// Parameters
READ  A <- C POTRF_TRSM(cblk)
RW    C <- (k == browk)    ? A(fcblk): C GEMM( prev )
        -> (k == browk1-1) ? C POTRF_TRSM(fcblk): C GEMM( next)

BODY
      DRYRUN(
	     /* compute_1dgemm */
          );
      printlog(
               "thread %d compute_1dgemm( %d , %d )\n",
               context->eu_id, k, fcblk);
END
