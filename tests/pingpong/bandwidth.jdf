extern "C" %{
#include <dague.h>
#include <data_distribution.h>
#include <data.h>
#include <stdarg.h>

#include <assert.h>

#include "bandwidth.h"

typedef struct {
    dague_ddesc_t  super;
    int            frags;
    int            size;
    dague_data_t **data;
    uint8_t       *ptr;
} my_datatype_t;

/**
 * This data is not distributed. A copy of the entire
 * array is available on each node.
 */
static inline uint32_t
rank_of_key(dague_ddesc_t *desc, dague_data_key_t key)
{
    my_datatype_t *array = (my_datatype_t*)desc;
    int f = (int)key; (void)f;

    assert( (f < array->frags) && (f >= 0) );
    return array->super.myrank;
}

static uint32_t
rank_of(dague_ddesc_t *desc, ...)
{
    va_list ap;
    int f;

    va_start(ap, desc);
    f = va_arg(ap, int);
    va_end(ap);

    return rank_of_key(desc, f);
}

static inline int32_t
vpid_of_key(dague_ddesc_t *desc, dague_data_key_t key)
{
    my_datatype_t *array = (my_datatype_t*)desc;
    int f = (key);

    assert( (f < array->size) && (f >= 0) );
    (void)array; (void)f;
    return 0;
}

static int32_t
vpid_of(dague_ddesc_t *desc, ...)
{
    va_list ap;
    int f;

    va_start(ap, desc);
    f = va_arg(ap, int);
    va_end(ap);

    return vpid_of_key(desc, f);
}

static inline dague_data_t* data_of_key(dague_ddesc_t *desc, dague_data_key_t key)
{
    my_datatype_t *array = (my_datatype_t*)desc;
    int f = (int)key;

    assert( (f < array->size) && (f >= 0) );
    (void)f;
    if(NULL == array->data[f]) {
        dague_data_t      *data;
        dague_data_copy_t *copy;

        array->data[f] = data = dague_data_new();
        data->key = f;
        data->nb_elts = array->size;

        copy = dague_data_copy_new(array->data[f], 0 /* main memory */);
        copy->device_private = array->ptr + f * array->size;
    }
    return (void*)(array->data[f]);
}

static dague_data_t* data_of(dague_ddesc_t *desc, ...)
{
    va_list ap;
    int f;

    va_start(ap, desc);
    f = va_arg(ap, int);
    va_end(ap);

    return data_of_key(desc, f);
}

static uint32_t data_key(dague_ddesc_t *desc, ...)
{
    my_datatype_t *dat = (my_datatype_t*)desc;
    va_list ap;
    int f;

    va_start(ap, desc);
    f = va_arg(ap, int);
    va_end(ap);

    assert( (f < dat->size) && (f >= 0) );

    return (uint32_t)f;
}

dague_ddesc_t*
create_and_distribute_data(int rank, int world, int frags, int size)
{
    my_datatype_t *m = (my_datatype_t*)calloc(1, sizeof(my_datatype_t));
    dague_ddesc_t *d = &(m->super);

    d->myrank = rank;
    d->nodes  = world;

    d->rank_of     = rank_of;
    d->rank_of_key = rank_of_key;
    d->data_of     = data_of;
    d->data_of_key = data_of_key;
    d->vpid_of     = vpid_of;
    d->vpid_of_key = vpid_of_key;

#if defined(DAGUE_PROF_TRACE)
    asprintf(&d->key_dim, "(%d)", size);
#endif  /* defined(DAGUE_PROF_TRACE) */
    d->key_base = strdup("A");
    d->data_key = data_key;

    m->frags = frags;
    m->size  = size;
    m->data  = (dague_data_t**)calloc(frags, sizeof(dague_data_t*));
    m->ptr   = (uint8_t*)calloc(frags * size, sizeof(uint8_t));

    return d;
}

void free_data(dague_ddesc_t *d)
{
    my_datatype_t *array = (my_datatype_t*)d;
    if(NULL != array->data) {
        /* TODO: free each dague_data_t element */
        free(array->data); array->data = NULL;
    }
    free(array->ptr); array->ptr = NULL;
    dague_ddesc_destroy(d);
    free(d);
}

/**
 * @param [IN] A    the data, already distributed and allocated
 * @param [IN] size size of each local data element
 * @param [IN] nb   number of iterations
 *
 * @return the dague object to schedule.
 */
dague_handle_t *bandwidth_New(dague_ddesc_t *A, int loops, int frags, int ws)
{
    dague_bandwidth_handle_t *o = NULL;
    
    if( (loops < 1) || (frags < 1) ) {
        fprintf(stderr, "To work, this test needs at lest 1 loop \n"
                        "  (instead of %d) and 1 frag (instead of %d)\n", loops, frags);
        return NULL;
    }

    o = dague_bandwidth_new(A, loops, frags, ws);

    return (dague_handle_t*)o;
}

/**
 * @param [INOUT] o the dague object to destroy
 */
void bw_destroy(dague_handle_t *o)
{
    DAGUE_INTERNAL_HANDLE_DESTRUCT(o);
}

%}

NT  /* number of turns */
NF  /* number of simultaneous fragments */
WS  /* worldsize: must be 1 by now */

SYNC(t)

t = 0 .. NT-1

: A(t % WS, 0)

CTL C -> C PING(t, 0 .. NF-1)
      <- (t > 0) ? C PONG(t-1, 0 .. NF-1)
BODY
    printf("SYNC(%d)\n", t);
END

PING(t, f)

t = 0 .. NT-1
f = 0 .. NF-1

: A(t % WS, f)

RW   T <- (t == 0) ? A(t % WS, f) : T PONG(t-1, f)
       -> T PONG(t, f)
CTL  C <- C SYNC(t)

; (t * (NT-1)) + f

BODY
    printf("PING(%d, %d)\n", t, f);
END

PONG(t, f)

t = 0 .. NT-1
f = 0 .. NF-1

: A(t % WS, f)

RW   T <- T PING(t, f)
       -> (t < NT) ? T PING(t+1, f) : A(t % WS, f)
CTL  C -> C SYNC(t+1)

; (t * (NT-1)) + f

BODY [type = CUDA]
    printf("PONG(%d, %d) -> CUDA\n", t, f);
END

BODY
    printf("PONG(%d, %d)\n", t, f);
END

extern "C" %{

int main(int argc, char *argv[])
{
    dague_context_t* dague;
    int rank, world, cores;
    int i, size, loops, frags;
    dague_ddesc_t *ddescA;
    dague_handle_t *bw_test;

    world = 1;
    rank = 0;

    cores = 1;
    dague = dague_init(cores, &argc, &argv);

    loops = 10;
    frags = 1;
    size = 1024;

    for( i = 1; i < argc; i++ ) {
        if(0 == strcmp(argv[i], "-n")) {
            loops = atoi(argv[i+1]); i++;
        }
        if(0 == strcmp(argv[i], "-f")) {
            frags = atoi(argv[i+1]); i++;
        }
        if(0 == strcmp(argv[i], "-l")) {
            size = atoi(argv[i+1]); i++;
        }
    }
    ddescA = create_and_distribute_data(rank, world, frags, size);
    dague_ddesc_set_key(ddescA, "A");
    
    bw_test = bandwidth_New(ddescA, loops, frags, world);
    dague_enqueue(dague, bw_test);

    dague_progress(dague);

#if defined(DAGUE_PROF_TRACE)
    {
        char *pname;
        asprintf(&pname, "bw-%d.profile", rank);
        dague_profiling_dump_dbp(pname);
        free(pname);
    }
#endif

    dague_fini(&dague);
    free_data(ddescA);

    return 0;
}
%}
